const phongVert="precision highp float;\n//precision highp int;\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main() {\n    vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n    // Pass varyings to fragment shader\n    vViewPosition = viewModelPosition.xyz;\n    gl_Position = uProjectionMatrix * viewModelPosition;  \n\n    vNormal = uNormalMatrix * aNormal;\n    vTexCoord = aTexCoord;\n\n    // TODO: this should be a uniform\n    vAmbientColor = vec3(0.0);\n\n    for (int i = 0; i < 5; i++) {\n        if (i < uAmbientLightCount) {\n            vAmbientColor += uAmbientColor[i];\n        }\n    }\n}\n",phongFrag="precision highp float;\n//precision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\n\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];\t\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n    float specular;\n    float diffuse;\n};\n\nfloat _phongSpecular(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float shininess) {\n    vec3 R = reflect(lightDirection, surfaceNormal);\n    return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n    return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector) {\n    vec3 lightDir = normalize(lightVector);\n\n    //compute our diffuse & specular terms\n    LightResult lr;\n\n    if (uSpecular) {\n        lr.specular = _phongSpecular(lightDir, viewDirection, normal, uShininess);\n    }\n\n    lr.diffuse = _lambertDiffuse(lightDir, normal);\n\n    return lr;\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n\nuniform float uFogEnabled;\nuniform vec3 uFogColor;\nuniform float uFogStart;\nuniform float uFogEnd;\n\nfloat fog_linear(float dist, float start, float end) {\n    return 1.0 - clamp((end - dist) / (end - start), 0.0, 1.0);\n}\n\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n    vec3 diffuse;\n    vec3 specular;\n    totalLight(vViewPosition, normalize(vNormal), diffuse, specular);\n\n    // Calculating final color as result of all lights (plus emissive term).\n    gl_FragColor = isTexture ? texture2D(uSampler, vTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = diffuse * gl_FragColor.rgb + \n                    vAmbientColor * uAmbientMatColor.rgb + \n                    specular * uSpecularMatColor.rgb + \n                    uEmissiveMatColor.rgb;\n\n    // fog\n    float fogDistance = gl_FragCoord.z / gl_FragCoord.w;\n    float fogAmount = fog_linear(fogDistance, uFogStart, uFogEnd);\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, uFogColor, fogAmount*uFogEnabled);\n}\n",_createFramebuffer=function(t){const e=new Framebuffer(this,t),r=this._renderer.resize;return this._renderer.resize=(t,n)=>{r.call(this._renderer,t,n),e.handleResize()},e};p5.prototype.createFramebuffer=_createFramebuffer,p5.Graphics.prototype.createFramebuffer=_createFramebuffer;const parentGetTexture=p5.RendererGL.prototype.getTexture;p5.RendererGL.prototype.getTexture=function(t){return t instanceof p5.Texture?t:parentGetTexture.call(this,t)};class RawTextureWrapper extends p5.Texture{constructor(t,e,r,n){return super(t,e),this.width=r,this.height=n,this}_getTextureDataFromSource(){return this.src}init(t){this._renderer.GL;this.glTex=t,this.glWrapS=this._renderer.textureWrapX,this.glWrapT=this._renderer.textureWrapY,this.setWrapMode(this.glWrapS,this.glWrapT),this.setInterpolation(this.glMinFilter,this.glMagFilter)}update(){return!1}}class Framebuffer{constructor(t,e={}){this._renderer=t._renderer;const r=this._renderer.GL;if(!r.getExtension("WEBGL_depth_texture"))throw new Error("Unable to create depth textures in this environment");this.colorFormat=this.glColorFormat(e.colorFormat),this.depthFormat=this.glDepthFormat(e.depthFormat),"float"!==e.colorFormat&&"float"!==e.depthFormat||r.getExtension("OES_texture_float")&&r.getExtension("OES_texture_float_linear")&&r.getExtension("WEBGL_color_buffer_float")||("float"===e.colorFormat&&(this.colorFormat=this.glColorFormat()),"float"===e.depthFormat&&(this.depthFormat=this.glDepthFormat()),console.warn("Warning: Unable to create floating point textures in this environment. Falling back to integers"));const n=r.createFramebuffer();if(!n)throw new Error("Unable to create a framebuffer");this.framebuffer=n,this.recreateTextures()}glColorFormat(t){const e=this._renderer.GL;return"float"===t?e.FLOAT:e.UNSIGNED_BYTE}glDepthFormat(t){const e=this._renderer.GL;return"float"===t?e.FLOAT:e.UNSIGNED_SHORT}handleResize(){const t=this.colorTexture,e=this.depthTexture;this.recreateTextures(),this.deleteTexture(t),this.deleteTexture(e)}recreateTextures(){const t=this._renderer.GL,e=this._renderer.width,r=this._renderer.height,n=this._renderer._pInst._pixelDensity,i=this._renderer._pInst._glAttributes.alpha,o=t.getParameter(t.TEXTURE_BINDING_2D),a=t.getParameter(t.FRAMEBUFFER_BINDING),s=t.createTexture();if(!s)throw new Error("Unable to create color texture");t.bindTexture(t.TEXTURE_2D,s),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,i?t.RGBA:t.RGB,e*n,r*n,0,i?t.RGBA:t.RGB,this.colorFormat,null);const l=t.createTexture();if(!l)throw new Error("Unable to create depth texture");t.bindTexture(t.TEXTURE_2D,l),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,t.DEPTH_COMPONENT,e*n,r*n,0,t.DEPTH_COMPONENT,this.depthFormat,null),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0),t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,l,0);const u=new RawTextureWrapper(this._renderer,l,e*n,r*n);this._renderer.textures.push(u);const h=new RawTextureWrapper(this._renderer,s,e*n,r*n);this._renderer.textures.push(h),t.bindTexture(t.TEXTURE_2D,o),t.bindFramebuffer(t.FRAMEBUFFER,a),this.depthTexture=l,this.depth=u,this.colorTexture=s,this.color=h}deleteTexture(t){this._renderer.GL.deleteTexture(t);const e=this._renderer.textures.findIndex((e=>e.src===t));-1!==e&&this._renderer.textures.splice(e,1)}draw(t){const e=this._renderer.GL,r=e.getParameter(e.FRAMEBUFFER_BINDING);e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),t(),e.bindFramebuffer(e.FRAMEBUFFER,r)}remove(){const t=this._renderer.GL;this.deleteTexture(this.colorTexture),this.deleteTexture(this.depthTexture),t.deleteFramebuffer(this.framebuffer)}}const _easing_c1=1.70158,_easing_c2=2.5949095,_easing_c3=2.70158,_easing_c4=2*Math.PI/3,_easing_c5=2*Math.PI/4.5;function linear(t){return t}function easeInQuad(t){return t*t}function easeOutQuad(t){return 1-(1-t)*(1-t)}function easeInOutQuad(t){return t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2}function easeInCubic(t){return t*t*t}function easeOutCubic(t){return 1-Math.pow(1-t,3)}function easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}function easeInQuart(t){return t*t*t*t}function easeOutQuart(t){return 1-Math.pow(1-t,4)}function easeInOutQuart(t){return t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2}function easeInQuint(t){return t*t*t*t*t}function easeOutQuint(t){return 1-Math.pow(1-t,5)}function easeInOutQuint(t){return t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2}function easeInSine(t){return 1-Math.cos(t*Math.PI/2)}function easeOutSine(t){return Math.sin(t*Math.PI/2)}function easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}function easeInExpo(t){return 0===t?0:Math.pow(2,10*t-10)}function easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}function easeInOutExpo(t){return 0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2}function easeInCirc(t){return 1-sqrt(1-Math.pow(t,2))}function easeOutCirc(t){return sqrt(1-Math.pow(t-1,2))}function easeInOutCirc(t){return t<.5?(1-sqrt(1-Math.pow(2*t,2)))/2:(sqrt(1-Math.pow(-2*t+2,2))+1)/2}function easeInBack(t){return 2.70158*t*t*t-1.70158*t*t}function easeOutBack(t){return 1+2.70158*Math.pow(t-1,3)+1.70158*Math.pow(t-1,2)}function easeInOutBack(t){return t<.5?Math.pow(2*t,2)*(7.189819*t-2.5949095)/2:(Math.pow(2*t-2,2)*(3.5949095*(2*t-2)+2.5949095)+2)/2}function easeInElastic(t){return 0===t?0:1===t?1:-Math.pow(2,10*t-10)*Math.sin((10*t-10.75)*_easing_c4)}function easeOutElastic(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin((10*t-.75)*_easing_c4)+1}function easeInOutElastic(t){return 0===t?0:1===t?1:t<.5?-Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*_easing_c5)/2:Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*_easing_c5)/2+1}function easeOutBounce(t){const e=7.5625,r=2.75;return t<1/r?e*t*t:t<2/r?e*(t-=1.5/r)*t+.75:t<2.5/r?e*(t-=2.25/r)*t+.9375:e*(t-=2.625/r)*t+.984375}function easeInBounce(t){return 1-easeOutBounce(1-t)}function easeInOutBounce(t){return t<.5?(1-easeOutBounce(1-2*t))/2:(1+easeOutBounce(2*t-1))/2}function randomDir(t=0,e){e||(e=createVector(0,-1,0)),e.normalize();const r=Math.random(),n=Math.random(),i=2*Math.PI*r,o=Math.acos(2*n-1),a=Math.sin(o)*Math.cos(i),s=Math.sin(o)*Math.sin(i),l=Math.cos(o);return createVector(lerp(e.x,a,t),lerp(e.y,s,t),lerp(e.z,l,t))}class Particle{constructor(t=5){this.maxLife=t,this.life=t}update(t){this.life-=t}render(){this.shape&&this.shape.render()}isDead(){return this.life<=0}get lifeRatio(){return 1-Math.max(0,Math.min(1,this.life/this.maxLife))}}class ParticleSystem{constructor(t,e){this.particles=[],this.delayMin=t,this.delayMax=e,this.time=0,this.delayBeforeSpawn=this.delayMin+Math.random()*(this.delayMax-this.delayMin)}addParticle(){const t=this.onCreate();this.particles.push(t)}update(t){let e=0;for(this.time+=t;this.time>=this.delayBeforeSpawn;)if(this.addParticle(),this.time-=this.delayBeforeSpawn,this.delayBeforeSpawn=this.delayMin+Math.random()*(this.delayMax-this.delayMin),e++,e>1e3){console.error("more than 1000 particles spawned, is there an infinite loop?");break}for(let e=this.particles.length-1;e>=0;e--){const r=this.particles[e];r.update(t),this.onUpdate(r,t),r.isDead()?this.particles.splice(e,1):r.render()}}onCreate(){return createParticle()}onUpdate(t){}render(){this.update(deltaTime/1e3)}}function createParticle(t){return new Particle(t)}function createParticleSystem(t,e){return new ParticleSystem(t,e)}function setupFog(t){const e=createShader(phongVert,phongFrag);e.isLightShader=()=>!0,t._defaultLightShader=e;const r=t._update;function n(){e.setUniform("uFogEnabled",t._boost.fogEnabled?1:0),e.setUniform("uFogColor",t._boost.fogColor||[0,0,0]),e.setUniform("uFogStart",t._boost.fogStart||0),e.setUniform("uFogEnd",t._boost.fogEnd||0)}t._update=function(){r.apply(t,Array.from(arguments)),t._boost.fogEnabled=!1};const i=t._setFillUniforms;t._setFillUniforms=function(){i.apply(t,Array.from(arguments)),n()};const o=t._setStrokeUniforms;t._setStrokeUniforms=function(){o.apply(t,Array.from(arguments)),n()}}function _fog(t=200,e=200,r=200,n=100,i=200){this._renderer._boost.fogEnabled=!0,this._renderer._boost.fogColor=[t/255,e/255,r/255],this._renderer._boost.fogStart=n,this._renderer._boost.fogEnd=i}p5.prototype.fog=_fog,p5.RendererGL.prototype.fog=_fog;class Shape3D{constructor(){this.position=createVector(),this.rotation=createVector(),this.scale=createVector(1,1,1),this.fill=color(255,255,255),this.stroke=null,this.ambientArgs=void 0,this.emissiveArgs=void 0,this.specularArgs=void 0,this.shininessValue=0,this.strokeWeight=1}noFill(){this.fill=null}noStroke(){this.stroke=null}ambientMaterial(){this.ambientArgs=Array.from(arguments)}emissiveMaterial(){this.emissiveArgs=Array.from(arguments)}specularMaterial(){this.specularArgs=Array.from(arguments)}shininess(t){this.shininessValue=t}render(){push(),this.fill?fill(this.fill):noFill(),this.stroke?(stroke(this.stroke),strokeWeight(this.strokeWeight)):noStroke(),this.ambientArgs&&ambientMaterial.apply(ambientMaterial,this.ambientArgs),this.emissiveArgs&&emissiveMaterial.apply(emissiveMaterial,this.emissiveArgs),this.specularArgs&&specularMaterial.apply(specularMaterial,this.specularArgs),shininess(this.shininessValue),translate(this.position.x,this.position.y,this.position.z),rotateZ(this.rotation.z),rotateX(this.rotation.x),rotateZ(this.rotation.y),scale(this.scale.x,this.scale.y,this.scale.z),this.renderShape(),pop()}renderShape(){}}function createShape(){return new Shape3D}class Sphere extends Shape3D{constructor(t=100,e=12,r=12){super(),this.radius=t,this.detailX=e,this.detailY=r}renderShape(){sphere(this.radius,this.detailX,this.detailY)}}function createSphere(t,e,r){return new Sphere(t,e,r)}class Box extends Shape3D{constructor(t=100,e,r){super(),e||(e=t),r||(r=t),this.size=createVector(t,e,r)}renderShape(){box(this.size.x,this.size.y,this.size.z)}}function createBox(t=100,e,r){return new Box(t,e,r)}class Plane extends Shape3D{constructor(t=100,e=100,r=1,n=1){super(),this.width=t,this.height=e,this.detailX=r,this.detailY=n}renderShape(){plane(this.width,this.height,this.detailX,this.detailY)}}function createPlane(t=100,e=100,r=1,n=1){return new Plane(t,e,r,n)}class Cylinder extends Shape3D{constructor(t=100,e=100,r=24,n=1,i=!0,o=!0){super(),this.radius=t,this.height=e,this.detailX=r,this.detailY=n,this.bottomCap=i,this.topCap=o}renderShape(){cylinder(this.radius,this.height,this.detailX,this.detailY,this.bottomCap,this.topCap)}}function createCylinder(t=100,e=100,r=24,n=1,i=!0,o=!0){return new Cylinder(t,e,r,n,i,o)}p5.prototype.setupBoost=function(){const t=this._renderer;t._boost={},setupFog(t),t.drawingContext.enable(t.drawingContext.CULL_FACE),t.drawingContext.cullFace(t.drawingContext.FRONT),angleMode(DEGREES)};
