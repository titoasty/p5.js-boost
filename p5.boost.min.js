const phongVert="precision highp float;\n//precision highp int;\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main() {\n    vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n    // Pass varyings to fragment shader\n    vViewPosition = viewModelPosition.xyz;\n    gl_Position = uProjectionMatrix * viewModelPosition;  \n\n    vNormal = uNormalMatrix * aNormal;\n    vTexCoord = aTexCoord;\n\n    // TODO: this should be a uniform\n    vAmbientColor = vec3(0.0);\n\n    for (int i = 0; i < 5; i++) {\n        if (i < uAmbientLightCount) {\n            vAmbientColor += uAmbientColor[i];\n        }\n    }\n}\n",phongFrag="precision highp float;\n//precision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\n\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];\t\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n    float specular;\n    float diffuse;\n};\n\nfloat _phongSpecular(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float shininess) {\n    vec3 R = reflect(lightDirection, surfaceNormal);\n    return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n    return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector) {\n    vec3 lightDir = normalize(lightVector);\n\n    //compute our diffuse & specular terms\n    LightResult lr;\n\n    if (uSpecular) {\n        lr.specular = _phongSpecular(lightDir, viewDirection, normal, uShininess);\n    }\n\n    lr.diffuse = _lambertDiffuse(lightDir, normal);\n\n    return lr;\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n\nuniform float uFogEnabled;\nuniform vec3 uFogColor;\nuniform float uFogStart;\nuniform float uFogEnd;\n\nfloat fog_linear(float dist, float start, float end) {\n    return 1.0 - clamp((end - dist) / (end - start), 0.0, 1.0);\n}\n\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n    vec3 diffuse;\n    vec3 specular;\n    totalLight(vViewPosition, normalize(vNormal), diffuse, specular);\n\n    // Calculating final color as result of all lights (plus emissive term).\n    gl_FragColor = isTexture ? texture2D(uSampler, vTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = diffuse * gl_FragColor.rgb + \n                    vAmbientColor * uAmbientMatColor.rgb + \n                    specular * uSpecularMatColor.rgb + \n                    uEmissiveMatColor.rgb;\n\n    // fog\n    float fogDistance = gl_FragCoord.z / gl_FragCoord.w;\n    float fogAmount = fog_linear(fogDistance, uFogStart, uFogEnd);\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, uFogColor, fogAmount*uFogEnabled);\n}\n",_createFramebuffer=function(t){const e=new Framebuffer(this,t),r=this._renderer.resize;return this._renderer.resize=(t,i)=>{r.call(this._renderer,t,i),e.handleResize()},e};p5.prototype.createFramebuffer=_createFramebuffer,p5.Graphics.prototype.createFramebuffer=_createFramebuffer;const parentGetTexture=p5.RendererGL.prototype.getTexture;p5.RendererGL.prototype.getTexture=function(t){return t instanceof p5.Texture?t:parentGetTexture.call(this,t)};class RawTextureWrapper extends p5.Texture{constructor(t,e,r,i){return super(t,e),this.width=r,this.height=i,this}_getTextureDataFromSource(){return this.src}init(t){this._renderer.GL;this.glTex=t,this.glWrapS=this._renderer.textureWrapX,this.glWrapT=this._renderer.textureWrapY,this.setWrapMode(this.glWrapS,this.glWrapT),this.setInterpolation(this.glMinFilter,this.glMagFilter)}update(){return!1}}class Framebuffer{constructor(t,e={}){this._renderer=t._renderer;const r=this._renderer.GL;if(!r.getExtension("WEBGL_depth_texture"))throw new Error("Unable to create depth textures in this environment");this.colorFormat=this.glColorFormat(e.colorFormat),this.depthFormat=this.glDepthFormat(e.depthFormat),"float"!==e.colorFormat&&"float"!==e.depthFormat||r.getExtension("OES_texture_float")&&r.getExtension("OES_texture_float_linear")&&r.getExtension("WEBGL_color_buffer_float")||("float"===e.colorFormat&&(this.colorFormat=this.glColorFormat()),"float"===e.depthFormat&&(this.depthFormat=this.glDepthFormat()),console.warn("Warning: Unable to create floating point textures in this environment. Falling back to integers"));const i=r.createFramebuffer();if(!i)throw new Error("Unable to create a framebuffer");this.framebuffer=i,this.recreateTextures()}glColorFormat(t){const e=this._renderer.GL;return"float"===t?e.FLOAT:e.UNSIGNED_BYTE}glDepthFormat(t){const e=this._renderer.GL;return"float"===t?e.FLOAT:e.UNSIGNED_SHORT}handleResize(){const t=this.colorTexture,e=this.depthTexture;this.recreateTextures(),this.deleteTexture(t),this.deleteTexture(e)}recreateTextures(){const t=this._renderer.GL,e=this._renderer.width,r=this._renderer.height,i=this._renderer._pInst._pixelDensity,n=this._renderer._pInst._glAttributes.alpha,o=t.getParameter(t.TEXTURE_BINDING_2D),a=t.getParameter(t.FRAMEBUFFER_BINDING),s=t.createTexture();if(!s)throw new Error("Unable to create color texture");t.bindTexture(t.TEXTURE_2D,s),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,n?t.RGBA:t.RGB,e*i,r*i,0,n?t.RGBA:t.RGB,this.colorFormat,null);const u=t.createTexture();if(!u)throw new Error("Unable to create depth texture");t.bindTexture(t.TEXTURE_2D,u),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,t.DEPTH_COMPONENT,e*i,r*i,0,t.DEPTH_COMPONENT,this.depthFormat,null),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0),t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,u,0);const l=new RawTextureWrapper(this._renderer,u,e*i,r*i);this._renderer.textures.push(l);const h=new RawTextureWrapper(this._renderer,s,e*i,r*i);this._renderer.textures.push(h),t.bindTexture(t.TEXTURE_2D,o),t.bindFramebuffer(t.FRAMEBUFFER,a),this.depthTexture=u,this.depth=l,this.colorTexture=s,this.color=h}deleteTexture(t){this._renderer.GL.deleteTexture(t);const e=this._renderer.textures.findIndex((e=>e.src===t));-1!==e&&this._renderer.textures.splice(e,1)}draw(t){const e=this._renderer.GL,r=e.getParameter(e.FRAMEBUFFER_BINDING);e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),t(),e.bindFramebuffer(e.FRAMEBUFFER,r)}remove(){const t=this._renderer.GL;this.deleteTexture(this.colorTexture),this.deleteTexture(this.depthTexture),t.deleteFramebuffer(this.framebuffer)}}const _easing_c1=1.70158,_easing_c2=2.5949095,_easing_c3=2.70158,_easing_c4=2*Math.PI/3,_easing_c5=2*Math.PI/4.5;function easeLinear(t){return t}function easeInQuad(t){return t*t}function easeOutQuad(t){return 1-(1-t)*(1-t)}function easeInOutQuad(t){return t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2}function easeInCubic(t){return t*t*t}function easeOutCubic(t){return 1-Math.pow(1-t,3)}function easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}function easeInQuart(t){return t*t*t*t}function easeOutQuart(t){return 1-Math.pow(1-t,4)}function easeInOutQuart(t){return t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2}function easeInQuint(t){return t*t*t*t*t}function easeOutQuint(t){return 1-Math.pow(1-t,5)}function easeInOutQuint(t){return t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2}function easeInSine(t){return 1-Math.cos(t*Math.PI/2)}function easeOutSine(t){return Math.sin(t*Math.PI/2)}function easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}function easeInExpo(t){return 0===t?0:Math.pow(2,10*t-10)}function easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}function easeInOutExpo(t){return 0===t?0:1===t?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2}function easeInCirc(t){return 1-sqrt(1-Math.pow(t,2))}function easeOutCirc(t){return sqrt(1-Math.pow(t-1,2))}function easeInOutCirc(t){return t<.5?(1-sqrt(1-Math.pow(2*t,2)))/2:(sqrt(1-Math.pow(-2*t+2,2))+1)/2}function easeInBack(t){return 2.70158*t*t*t-1.70158*t*t}function easeOutBack(t){return 1+2.70158*Math.pow(t-1,3)+1.70158*Math.pow(t-1,2)}function easeInOutBack(t){return t<.5?Math.pow(2*t,2)*(7.189819*t-2.5949095)/2:(Math.pow(2*t-2,2)*(3.5949095*(2*t-2)+2.5949095)+2)/2}function easeInElastic(t){return 0===t?0:1===t?1:-Math.pow(2,10*t-10)*Math.sin((10*t-10.75)*_easing_c4)}function easeOutElastic(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin((10*t-.75)*_easing_c4)+1}function easeInOutElastic(t){return 0===t?0:1===t?1:t<.5?-Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*_easing_c5)/2:Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*_easing_c5)/2+1}function easeOutBounce(t){const e=7.5625,r=2.75;return t<1/r?e*t*t:t<2/r?e*(t-=1.5/r)*t+.75:t<2.5/r?e*(t-=2.25/r)*t+.9375:e*(t-=2.625/r)*t+.984375}function easeInBounce(t){return 1-easeOutBounce(1-t)}function easeInOutBounce(t){return t<.5?(1-easeOutBounce(1-2*t))/2:(1+easeOutBounce(2*t-1))/2}function randomDir(t=1,e){e||(e=createVector(0,-1,0)),e.normalize();const r=Math.random(),i=Math.random(),n=2*Math.PI*r,o=Math.acos(2*i-1),a=Math.sin(o)*Math.cos(n),s=Math.sin(o)*Math.sin(n),u=Math.cos(o);return createVector(lerp(e.x,a,t),lerp(e.y,s,t),lerp(e.z,u,t)).normalize()}class Particle{constructor(t=5){this.maxLife=t,this.life=t}update(t){this.life-=t}draw(){}isDead(){return this.life<=0}get lifeRatio(){return 1-Math.max(0,Math.min(1,this.life/this.maxLife))}}class ParticleSystem{constructor(t,e,r){this.particles=[],this.delayMin=t,this.delayMax=e,this.onCreateParticle=r.bind(this),this.time=0,this.delayBeforeSpawn=this.delayMin+Math.random()*(this.delayMax-this.delayMin)}addParticle(){this.particles.push(this.onCreateParticle())}draw(){const t=deltaTime/1e3;let e=0;for(this.time+=t;this.time>=this.delayBeforeSpawn;)if(this.addParticle(),this.time-=this.delayBeforeSpawn,this.delayBeforeSpawn=this.delayMin+Math.random()*(this.delayMax-this.delayMin),e++,e>1e3){console.error("more than 1000 particles spawned, are you sure about that?");break}for(let e=this.particles.length-1;e>=0;e--){const r=this.particles[e];r.update(t),r.isDead()?this.particles.splice(e,1):r.draw()}}}function setupFog(t){const e=createShader(phongVert,phongFrag);e.isLightShader=()=>!0,t._defaultLightShader=e;const r=t._update;function i(){e.setUniform("uFogEnabled",t._boost.fogEnabled?1:0),e.setUniform("uFogColor",t._boost.fogColor||[0,0,0]),e.setUniform("uFogStart",t._boost.fogStart||0),e.setUniform("uFogEnd",t._boost.fogEnd||0)}t._update=function(){r.apply(t,Array.from(arguments)),t._boost.fogEnabled=!1};const n=t._setFillUniforms;t._setFillUniforms=function(){n.apply(t,Array.from(arguments)),i()};const o=t._setStrokeUniforms;t._setStrokeUniforms=function(){o.apply(t,Array.from(arguments)),i()}}function _fog(t=200,e=200,r=200,i=100,n=200){this._renderer._boost.fogEnabled=!0,this._renderer._boost.fogColor=[t/255,e/255,r/255],this._renderer._boost.fogStart=i,this._renderer._boost.fogEnd=n}p5.prototype.createParticle=function(t){return new Particle(t)},p5.prototype.createParticleSystem=function(t,e,r){return new ParticleSystem(t,e,r)},p5.prototype.fog=_fog,p5.RendererGL.prototype.fog=_fog;class Object3D{constructor(){this.children=[],this.position=createVector(),this.rotation=createVector(),this.scale=createVector(1,1,1)}draw(){push(),translate(this.position.x,this.position.y,this.position.z),rotateZ(this.rotation.z),rotateX(this.rotation.x),rotateY(this.rotation.y),scale(this.scale.x,this.scale.y,this.scale.z),this.drawShape();for(const t of this.children)t.render();pop()}drawShape(){}}class Shape3D extends Object3D{constructor(){super(),this.fill=color(255,255,255),this.stroke=null,this.ambientArgs=void 0,this.emissiveArgs=void 0,this.specularArgs=void 0,this.shininessArgs=void 0,this.strokeWeight=1}noFill(){this.fill=null}noStroke(){this.stroke=null}ambientMaterial(){this.ambientArgs=Array.from(arguments)}emissiveMaterial(){this.emissiveArgs=Array.from(arguments)}specularMaterial(){this.specularArgs=Array.from(arguments)}shininess(){this.shininessArgs=Array.from(arguments)}draw(){push(),this.fill?fill(this.fill):noFill(),this.stroke?(stroke(this.stroke),strokeWeight(this.strokeWeight)):noStroke(),this.ambientArgs&&ambientMaterial(...this.ambientArgs),this.emissiveArgs&&emissiveMaterial(...this.emissiveArgs),this.specularArgs&&specularMaterial(...this.specularArgs),this.shininessArgs&&shininess(...this.shininessArgs),super.draw(),pop()}drawShape(){}}function _createShape(t,e){const r=new Shape3D;r.drawShape=t.bind(r);for(const t in e)r[t]=e[t];return r}p5.prototype.createShape=_createShape,p5.prototype.createSphere=function(t=100,e=12,r=12){return this.createShape((function(){sphere(this.radius,this.detailX,this.detailY)}),{radius:t,detailX:e,detailY:r})},p5.prototype.createBox=function(t=100,e,r){return this.createShape((function(){box(this.size.x,this.size.y,this.size.z)}),{size:createVector(t,e||t,r||t)})},p5.prototype.createPlane=function(t=100,e=100,r=1,i=1){return this.createShape((function(){plane(this.width,this.height,this.detailX,this.detailY)}),{width:t,height:e,detailX:r,detailY:i})},p5.prototype.createCylinder=function(t=100,e=100,r=24,i=1,n=!0,o=!0){return this.createShape((function(){cylinder(this.radius,this.height,this.detailX,this.detailY,this.bottomCap,this.topCap)}),{radius:t,height:e,detailX:r,detailY:i,bottomCap:n,topCap:o})},p5.prototype.createCone=function(t=100,e=100,r=24,i=1,n=!0){return this.createShape((function(){cone(this.radius,this.height,this.detailX,this.detailY,this.cap)}),{radius:t,height:e,detailX:r,detailY:i,cap:n})},p5.prototype.createEllipsoid=function(t=100,e=100,r=100,i=12,n=12){return this.createShape((function(){ellipsoid(this.radiusX,this.radiusY,this.radiusZ,this.detailX,this.detailY)}),{radiusX:t,radiusY:e,radiusZ:r,detailX:i,detailY:n})},p5.prototype.createTorus=function(t=100,e=50,r=12,i=12){return this.createShape((function(){torus(this.radius,this.tubeRadius,this.detailX,this.detailY)}),{radius:t,tubeRadius:e,detailX:r,detailY:i})},p5.prototype.setupBoost=function(){const t=this._renderer;t._boost={},setupFog(t),t.drawingContext.enable(t.drawingContext.CULL_FACE),t.drawingContext.cullFace(t.drawingContext.FRONT),angleMode(DEGREES)};
